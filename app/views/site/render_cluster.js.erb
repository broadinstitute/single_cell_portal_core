<%#
This file will be mostly removed by SCP-2857, likely leaving only `rawPlot` and
code to add response to current plot data.
%>

// TODO (SCP-2857): Probably put this in the Ajax succeed / complete (or better,
// `await fetch` equivalent).
var plotEvent = window.SCP.startPendingEvent('plot:scatter', window.SCP.getLogPlotProps());

const rawPlot = {
  data: <%= raw @plot_data %>,
  description: "<%= escape_javascript(render plain: description) %>",
  is3D: <%= @cluster.is_3d? %>,
  domainRanges: <%= raw @cluster.domain_ranges.to_json %>,
  axes: <%= raw @axes_full.to_json %>,
  hasCoordinateLabels: <%= @cluster.has_coordinate_labels? %>,
  coordinateLabels: <%= raw @coordinate_labels.to_json %>
}

window.SCP.cluster = rawPlot;

// Consider putting into a dictionary instead of a list
window.SCP.plots.push(rawPlot);

// TODO (SCP-2857): Remove hard-coding when UI for selecting n-many cluster + spatial
// plots is something we can develop against.
numPlots = 2

// Incremented upon drawing scatter plot; enables unique plot IDs
window.SCP.scatterCount = 0;

// render colorscale picker if needed
if (<%= @selected_annotation[:type] == 'numeric' %>) {
    $('#toggle-plots').html("");
} else {
    $('#toggle-plots').html("<%= escape_javascript(render partial: 'trace_toggle') %>");
    $('#toggle-traces').tooltip({container: 'body', placement: 'left', trigger: 'hover'});
}

const target = '#plots .panel-body'
const rect = calculatePlotRect(numPlots)

// Duplicate calls are merely for proof-of-concept, showing we can
// render plots side-by-side
renderScatterPlot(target, rawPlot, rect, plotlyLabelFont)
renderScatterPlot(target, rawPlot, rect, plotlyLabelFont)

// set CLUSTER_TYPE to control annotations behavior
CLUSTER_TYPE = '<%= @cluster.cluster_type %>'

// set the cluster field in the search box to scope search correctly
$('#search_cluster').val("<%= params[:cluster] %>");

// resize listener
$(window).on('resizeEnd', function() {
    const layout = window.SCP.scatterPlotLayout;
    var {height} = calculatePlotViewport(numPlots);
    if (layout.height === height) {
        Plotly.newPlot('cluster-plot-' + window.SCP.scatterCount, data, layout);
    } else {
        layout.height = height;
        Plotly.relayout('cluster-plot-' + window.SCP.scatterCount, layout);
    }
});

// Ensure cluster plot is sized properly upon clicking Explore tab (SCP-1106)
$('body').on('click', '#study-visualize-nav > a', function() {
  window.exploreResizeTO = setTimeout(function () {
    $(window).trigger('resizeEnd');
    delete window.exploreResizeTO;
    $('#study-visualize-nav > a').off('click');
  }, 50);
})

// attach click event for toggle switch
$('#toggle-traces').click(function() {
    togglePlotlyTraces('cluster-plot-' + window.SCP.scatterCount);
});

// attach click event for toggle violin
$('#toggle-violin').click(function() {
    toggleViolinPlot();
});

// stop spinner
$('#cluster-plot-' + window.SCP.scatterCount).data('spinner').stop();

// monitor rendering status for tests
$('#cluster-plot-' + window.SCP.scatterCount).data('rendered', true);

enableDefaultActions();
closeUserAnnotationsForm();

var requestUrl = '<%= javascript_safe_url(request.fullpath) %>';
gaTrack(requestUrl, 'Single Cell Portal');

$(document).trigger('scpPlotsDidRender');
plotEvent.complete();

<% if @analysis_outputs.key?('ideogram.js') %>
window.ideogramInferCnvSettings = <%= raw @study.get_ideogram_infercnv_settings(params[:cluster], params[:annotation]).to_json %>;
var ideogramAnnotsUrl = '<%= raw @analysis_outputs['ideogram.js'] %>';
initializeIdeogram(ideogramAnnotsUrl);
<% else %>
warnIdeogramOfNumericCluster();
<% end %>

<%= render partial: 'annotation_warning.js' %>
